<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | TechToy]]></title>
  <link href="http://ensonmj.github.com/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://ensonmj.github.com/"/>
  <updated>2012-06-19T21:03:03+08:00</updated>
  <id>http://ensonmj.github.com/</id>
  <author>
    <name><![CDATA[ensonmj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux 环境变量的多种设置途径]]></title>
    <link href="http://ensonmj.github.com/blog/2012/06/19/linux-huan-jing-bian-liang-de-duo-chong-she-zhi-tu-jing/"/>
    <updated>2012-06-19T20:15:00+08:00</updated>
    <id>http://ensonmj.github.com/blog/2012/06/19/linux-huan-jing-bian-liang-de-duo-chong-she-zhi-tu-jing</id>
    <content type="html"><![CDATA[<p>上一篇提到有空写写Linux设置环境变量的方法，没想到一眨眼就是一周，怎一个懒字了得。</p>

<p>其实这篇文章主要翻译自一篇<a href="https://numberformat.wordpress.com/2010/01/24/setting-environment-variables-in-ubuntu/">英文blog</a>，有喜欢阅读英文资料的可以前去一观。</p>

<h3>会话级环境变量</h3>

<p>会话级的环境变量只影响特定的登录用户，用户主目录下有几个隐藏文件可以用于进行此设置。</p>

<ul>
<li><p><code>~/.profile</code> - 这个脚本在启动DM（Display Manager）时被自动加载；如果你使用控制台方式登录，它也会被加载，其实确切的说，只要是使用<strong> login shell </strong>，此文件就会被加载。</p></li>
<li><p><code>~/.bash_profile</code>或者<code>~/.bash_login</code> - 这两个文件中只要有一个存在，启动login shell的时候就会加载这两个文件之一，而不会加载<code>~/.profile</code>，如果两个都存在，bash优先加载<code>~/.bash_profile</code>；这两个文件对图形环境不会有影响，DM启动时不会加载。<br/>
其实一般情况下<code>～/.bash_profile</code>的内容只有一行，就是加载下面要讲到的<code>~/.bashrc</code>文件。</p>

<p>  $cat ~/.bash_profile<br/>
  . $HOME/.bashrc</p></li>
<li><p><code>~/.bashrc</code> - 这个文件一般使用比较广泛，也比较方便。每次执行bash时都会加载一次此文件（非login shell），因此有点小小的冗余——变量会被多次设置，不过这不是什么大问题；这个文件在启动图形界面时也会被加载。</p></li>
</ul>


<p>我个人的设置是<code>~/.bashrc</code>搞定图形界面和非login shell，<code>~/.bash_profile</code>搞定login shell。</p>

<h3>系统级环境变量</h3>

<p>系统级的环境变量则会影响到所有使用这台机器的用户，相关配置文件都在<code>/etc</code>目录下。</p>

<ul>
<li><p><code>/etc/profile</code> - 这个文件在每次启动login shell或者DM时执行，系统默认其实只做了很少一部分设置，其他设置还是加载<code>/etc/bash.bashrc</code>来完成的。</p></li>
<li><p><code>/etc/bash.bashrc</code> - 这是<code>~/.bashrc</code>文件的系统级版本，作用基本类似。</p></li>
<li><p><code>/etc/environment</code> - 这个有别于上面提到的所有文件，它不是一个脚本文件，仅仅是一个包含“键值对”的配置文件，这个文件一般用来设置系统级的<code>locale</code>和<code>path</code>。上一篇中使用<code>systemd</code>替换<code>sysVinit</code>的过程中，就用了此文件来设置系统级的locale。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arch使用systemd替换sysVinit]]></title>
    <link href="http://ensonmj.github.com/blog/2012/06/12/archshi-yong-systemdti-huan-sysvinit/"/>
    <updated>2012-06-12T20:34:00+08:00</updated>
    <id>http://ensonmj.github.com/blog/2012/06/12/archshi-yong-systemdti-huan-sysvinit</id>
    <content type="html"><![CDATA[<p>忘了最早是怎么知道<code>systemd</code>的了，最近想起来折腾它还是因为无意中看到了Arch论坛上一篇<a href="https://bbs.archlinux.org/viewtopic.php?id=96316">帖子</a>，帖子内容跨度了两年，对于技术贴来说，我第一次见到。要想把整个帖子内容都看完有点不现实，大体上整个帖子就是在讨论Arch中怎么用<code>systemd</code>替换现有的<code>sysVinit</code>。</p>

<p><code>systemd</code>是一个新的init系统，有关它的详细介绍参见Lennart的<a href="http://0pointer.de/blog/projects/systemd.html">blog</a>，文章很长，推荐技术宅们详细阅读下，看完你会觉得受益匪浅，甚至也许你就会像我一样迫不及待的想要尝试一下了。</p>

<p>其实整个切换过程并不复杂，按照<a href="https://wiki.archlinux.org/index.php/Systemd">Arch wiki</a>上一步一步来就行了，我这里只是记录下我自己的整个操作过程，算是Wiki的中文简化版吧。</p>

<h3>安装<code>systemd</code></h3>

<pre><code>$sudo pacman -S systemd
</code></pre>

<p>Arch当前安装完会有一些提示，可以暂时不用管，后面会用到。</p>

<pre><code>ln -s '/usr/lib/systemd/system/getty@.service' '/etc/systemd/system/getty.target.wants/getty@tty1.service'
:: Append 'init=/bin/systemd' to your kernel command line in your
   bootloader to replace sysvinit with systemd
</code></pre>

<!--more-->


<h3>创建新的启动项以使用<code>systemd</code>管理整个系统</h3>

<p>说一下我当前系统的环境，我现在使用的是Arch x86_64</p>

<pre><code>$uname -a
Linux ENSONMJ-PC **3.3.7-1-ARCH** #1 SMP PREEMPT Tue May 22 00:26:26 CEST 2012 x86_64 GNU/Linux
</code></pre>

<p>bootloader使用的是Grub，不是Grub2，根分区在第一块硬盘的第三个分区上，所以启动项的配置是修改<code>/boot/grub/menu.lst</code>文件，添加如下启动条目（参数因人而异，不能照抄）：</p>

<pre><code># (0) Arch Linux
title  Arch Linux [systemd]
root   (hd0,**2**)
kernel /boot/vmlinuz-linux root=/dev/sda**3** vga=795 ro **init=/bin/systemd**
initrd /boot/initramfs-linux.img
</code></pre>

<h3>配置系统以使用native的systemd</h3>

<p>这部分就是按照Wiki的说明按部就班的来：</p>

<p>1）hostname 设置</p>

<p>编辑<code>/etc/hostname</code>文件，里面写上你的hostname</p>

<pre><code>YOUR_HOSTNAME
</code></pre>

<p>2）console and keymap 设置</p>

<p>编辑<code>/etc/vconsole.conf</code>文件, 内容如下：</p>

<pre><code>KEYMAP="us"
FONT=lat9w-16 #rc.conf中留空了
FONT_MAP=8859-1_to_uni #rc.conf中留空了
</code></pre>

<p>其实<code>FONT</code>和<code>FONT_MAP</code>在原来<code>/etc/rc.conf</code>中我都留空了，没有设置值，这里只是照抄了wiki，效果不好可以后续再调整；关KEYMAP的介绍可以参见<a href="https://wiki.archlinux.org/index.php/KEYMAP">Arch wiki</a>。</p>

<p>3）locale 设置</p>

<p>编辑<code>/etc/locale.conf</code>文件，内容如下：</p>

<pre><code>LANG="en_US.UTF-8"
LC_COLLATE="C"
</code></pre>

<p>4) timezone设置</p>

<p>编辑<code>/etc/timezone</code>文件，内容如下：</p>

<pre><code>Asia/Shanghai
</code></pre>

<p>注意：<code>systemd</code>不支持<code>localtime</code>，如果之前使用的是<code>localtime</code>（装双系统出于兼容windows的可能会这么设置），那么需要改为<code>utc</code>:</p>

<pre><code>hwclock --systohc --utc
</code></pre>

<p>5) 配置内核模块</p>

<p>如果需要在启动时加载内核模块，需要在<code>/etc/modules-load.d/</code>下创建相应的文件，我只用了个<code>kvm-intel</code>模块，某次鼓捣<code>kvm</code>的遗留产物，于是创建<code>/etc/modules-load.d/kvm.conf</code>文件，内容如下：</p>

<pre><code>kvm-intel
</code></pre>

<p>其实文件名是可以任意取的，只要内容正确就行。同时还可以配置内核模块黑名单，有兴趣的自己研究，<a href="https://wiki.archlinux.org/index.php/Systemd#Configure_kernel_modules_blacklist">参考链接</a>，我暂不需要这功能。</p>

<p>6）临时文件</p>

<p>可以用来定义哪些文件该何时清理，这个未配置，有空再研究。</p>

<p>7）日志</p>

<p>从Version 38开始，<code>systemd</code>开始有了自带的日志系统，默认日志写入<code>/run/systemd/journal/</code>目录下,重启后会消失；如果需要非易失的日志,可以创建<code>/var/log/journal/</code>目录。另外也可以考虑将<code>systemd</code>的日志重定向到<code>syslog</code>中，不感兴趣。</p>

<p>8）网络</p>

<p>我适用NetWorkManager配置网络，启用<code>NetworkManager.service</code>就行</p>

<pre><code>systemctl enable NetworkManager.service
</code></pre>

<p>9) 启用图形界面(默认）</p>

<p><code>systemd</code>安装后，默认是适用图形界面的，此步可以省略了。</p>

<pre><code>$ls -l /usr/lib/systemd/system/default.target 
lrwxrwxrwx 1 root root 16 Jun  5 04:12 /usr/lib/systemd/system/default.target -&gt; graphical.target
</code></pre>

<p>10) 使用DE(Display Manager),具体对于我来说就是<code>gdm</code></p>

<p>目前需要安装AUR中的<code>systemd-arch-units</code>包</p>

<pre><code>yaourt -S systemd-arch-units
</code></pre>

<p>然后启用<code>gdm.service</code>:</p>

<pre><code>systemctl enable gdm.service
</code></pre>

<p>如果在<code>/etc/locale.conf</code>文件中设置了locale，则为了DE使用同样的locale，需要在<code>/etc/environment</code>文件中
设置相应的系统级环境变量，其文件内容如下：</p>

<pre><code>LANG="en_US.utf8"
</code></pre>

<p>关于环境变量的多种设置方法，我准备在下一篇总结一下。</p>

<p>11）Daemon 设置</p>

<p>我原来<code>/etc/rc.conf</code>中<code>DAEMONS</code>数组设置如下：</p>

<pre><code>DAEMONS=(!hwclock syslog-ng dbus netfs @alsa @crond @networkmanager @sshd @sensors @libvirtd @dropboxd)
</code></pre>

<p>其中<code>hwclock</code>不使用；<code>syslog-ng</code>被<code>systemd</code>自带的<code>journald</code>取代，不用设置；<code>dbus</code>默认enable；<code>netfs</code>忘了我用来干嘛的了，暂不管；<code>alsa</code>好像也不需要特别设置；<code>crond</code>我一直没用，不设置；<code>networkmanager</code>已经设置；<code>sshd</code>家里电脑也一直用不上；最后三个<code>sensors</code>,<code>libvirtd</code>,<code>dropboxd</code>没发现有现成的service文件，需要自己创建，暂时搁置。</p>

<p>12）支持休眠</p>

<p>到目前位置，整个<code>systemd</code>就配置完了，重启之后就可以使用了。但是如果就这样结束的话，<code>gnome</code>中的<code>suspend</code>就无法使用，要想支持休眠还需要安装<code>systemd-sysvcompat</code>包。</p>

<pre><code>pacman -S systemd-sysvcompat
</code></pre>

<p>安装<code>systemd-sysvcompat</code>时会提示冲突，需要同时卸载<code>sysvint</code>和<code>initscripts</code>。</p>

<p><strong>另外，在安装过<code>systemd-sysvcompat</code>之后，就完全用<code>systemd</code>取代了<code>sysVinit</code>了，此时，grub中的内核启动参数<code>init=/bin/systemd</code>也可以去掉了。</strong></p>

<p>最后附一张我使用<code>systemd</code>后系统启动时序图，可以看到整个启动过程只用了9s，神速啊。时序图可以使用如下命令生成：</p>

<pre><code>systemd-analyze plog &gt; boot.svg
</code></pre>

<p><img src="/images/boot.svg" title="Boot with systemd in arch" alt="Boot with systemd in arch" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]Linux inode 介绍]]></title>
    <link href="http://ensonmj.github.com/blog/2012/06/02/zhuan-linux-inode-jie-shao/"/>
    <updated>2012-06-02T21:13:00+08:00</updated>
    <id>http://ensonmj.github.com/blog/2012/06/02/zhuan-linux-inode-jie-shao</id>
    <content type="html"><![CDATA[<p>本文转自<a href="http://www.cnblogs.com/itech/archive/2012/05/15/2502284.html">http://www.cnblogs.com/itech/archive/2012/05/15/2502284.html</a>，在原文基础上稍加排版，纯属收藏</p>

<p>一、inode是什么？</p>

<p>理解inode，要从文件储存说起。文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于0.5KB）。</p>

<p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>

<p>文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为"索引节点"。</p>

<!--more-->


<p>
二、inode的内容</p>

<p>inode包含文件的元信息，具体来说有以下内容：</p>

<blockquote><p>文件的字节数<br/>
文件拥有者的User ID<br/>
文件的Group ID<br/>
文件的读、写、执行权限<br/>
文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。<br/>
链接数，即有多少文件名指向这个inode<br/>
文件数据block的位置</p></blockquote>

<p>可以用<code>stat</code>命令，查看某个文件的inode信息：</p>

<pre><code>$stat example.txt 
  File: ‘example.txt’
  Size: 5           Blocks: 8          IO Block: 4096   regular file
Device: 805h/2053d  Inode: 13771400    Links: 1
Access: (0644/-rw-r--r--)  Uid: ( 1000/ ensonmj)   Gid: (  100/   users)
Access: 2012-06-02 21:21:37.546284322 +0800
Modify: 2012-06-02 21:22:02.769617202 +0800
Change: 2012-06-02 21:22:02.769617202 +0800
 Birth: -
</code></pre>

<p>总之，除了<strong>文件名</strong>以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p>

<p>三、inode的大小</p>

<p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p>

<p>每个inode节点的大小，一般是128B或256B。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128B，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p>

<p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用<code>df</code>命令：</p>

<pre><code>$df -i
Filesystem       Inodes  IUsed    IFree IUse% Mounted on
rootfs          6250496 325389  5925107    6% /
/dev            1019935    624  1019311    1% /dev
run             1020674    464  1020210    1% /run
/dev/sda3       6250496 325389  5925107    6% /
shm             1020674      6  1020668    1% /dev/shm
/dev/sda5      14983168 116890 14866278    1% /home
</code></pre>

<p>查看每个inode节点的大小，可以用如下命令（这个命令在我本机执行失败）：</p>

<pre><code>sudo dumpe2fs -h /dev/sda | grep "Inode size"
</code></pre>

<p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p>

<p>四、inode号码</p>

<p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p>

<p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p>

<p>使用<code>ls -i</code>命令，可以看到文件名对应的inode号码：</p>

<pre><code>$ls -i example.txt 
13771400 example.txt
</code></pre>

<p>五、目录文件</p>

<p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p>

<p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p>

<p><code>ls</code>命令只列出目录文件中的所有文件名：</p>

<pre><code>ls
</code></pre>

<p>ls -i命令列出整个目录文件，即文件名和inode号码：</p>

<pre><code>ls -i
</code></pre>

<p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p>

<pre><code>ls -l
</code></pre>

<p>六、硬链接</p>

<p>一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，<strong>多个文件名指向同一个inode号码</strong>。这意味着，可以用不同的文件名访问同样的内容；<strong>对文件内容进行修改，会影响到所有文件名</strong>；但是，<strong>删除一个文件名，不影响另一个文件名的访问</strong>。这种情况就被称为"硬链接"（hard link）。</p>

<p><code>ln</code>命令可以创建硬链接：</p>

<pre><code>ln 源文件 目标文件
</code></pre>

<p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做"链接数"，记录指向该inode的文件名总数，这时就会增加1。反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p>

<p>这里顺便说一下目录文件的"链接数"。创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）,这里的2是父目录对其的“硬链接”和当前目录下的".硬链接“。</p>

<p>七、软链接</p>

<p>除了硬链接以外，还有一种特殊情况。文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接（symbolic link）。</p>

<p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。这是软链接与硬链接最大的不同：<strong>文件A指向文件B的文件名，而不是文件B的inode号码</strong>，文件B的inode"链接数"不会因此发生变化。</p>

<p><code>ln -s</code>命令可以创建软链接。</p>

<pre><code>ln -s 源文文件或目录 目标文件或目录
</code></pre>

<p>八、inode的特殊作用</p>

<p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象：</p>

<ol>
<li>有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li>
<li>移动文件或重命名文件，只是改变文件名，不影响inode号码。</li>
<li>打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li>
</ol>


<p>第3点使得软件更新变得简单，<strong>可以在不关闭软件的情况下进行更新，不需要重启</strong>。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p>

<p>九 实际问题</p>

<p>在一台配置较低的Linux服务器（内存、硬盘比较小）的/data分区内创建文件时，系统提示磁盘空间不足，用<code>df -h</code>命令查看了一下磁盘使用情况，发现/data分区只使用了66%，还有12G的剩余空间，按理说不会出现这种问题。后来用<code>df -i</code>查看了一下/data分区的索引节点(inode)，发现已经用满(IUsed=100%)，导致系统无法创建新目录和文件。</p>

<p>查找原因：<br/>
/data/cache目录中存在数量非常多的小字节缓存文件，占用的block不多，但是占用了大量的inode。 <br/>
解决方案：<br/>
1、删除/data/cache目录中的部分文件，释放出/data分区的一部分inode。<br/>
2、用软连接将空闲分区/opt中的newcache目录连接到/data/cache，使用/opt分区的inode来缓解/data分区inode不足的问题：</p>

<pre><code>ln -s /opt/newcache /data/cache 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arch HDMI声音输出（续）]]></title>
    <link href="http://ensonmj.github.com/blog/2012/05/14/arch-hdmisheng-yin-shu-chu-%28xu-%29/"/>
    <updated>2012-05-14T20:42:00+08:00</updated>
    <id>http://ensonmj.github.com/blog/2012/05/14/arch-hdmisheng-yin-shu-chu-(xu-)</id>
    <content type="html"><![CDATA[<p>上一篇说到PulseAudio由于一个bug导致HDMI默认创建的设备不对，无法输出声音。最新的PulseAudio 2.0修复了此bug，现在可以不用做任何特殊配置就可以使用HDMI设备了。</p>

<p>另外说一句，Octopress好像不支持原文修改更新，只好再写了这篇短文，算是对上一篇的更新。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arch HDMI 声音输出]]></title>
    <link href="http://ensonmj.github.com/blog/2012/05/04/arch-hdmi-sheng-yin-shu-chu/"/>
    <updated>2012-05-04T22:36:00+08:00</updated>
    <id>http://ensonmj.github.com/blog/2012/05/04/arch-hdmi-sheng-yin-shu-chu</id>
    <content type="html"><![CDATA[<p>最近又开始习惯性折腾了，这次折腾的对象是HDMI的音频输出。自从上次显卡的DVI接口导致电脑自动重启之后就开始使用HDMI接口连接显示器了。HDMI是可以同时传输视频和音频信号的，正好我的显示器也自带扬声器，可以充分利用起来。但理想很丰满，现实却很骨感，测试无法输出声音。</p>

<!--more-->


<p>按照Arch Wiki上有关<a href="https://wiki.archlinux.org/index.php/Advanced_Linux_Sound_Architecture">ALSA</a>和<a href="https://wiki.archlinux.org/index.php/PulseAudio">PulseAudio</a>的说明跑了一遍，电脑上现有的声音输出设备如下：</p>

<pre><code>$aplay -l
**** List of PLAYBACK Hardware Devices ****　
card 0: NVidia [HDA NVidia], device 3: HDMI 0 &gt; [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 0: NVidia [HDA NVidia], device 7: HDMI 0 &gt; [HDMI 0]
  Subdevices: 0/1
  Subdevice #0: subdevice #0
card 0: NVidia [HDA NVidia], device 8: HDMI 0 &gt; [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 0: NVidia [HDA NVidia], device 9: HDMI 0 &gt; [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: PCH [HDA Intel PCH], device 0: ALC889 &gt; Analog [ALC889 Analog]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
card 1: PCH [HDA Intel PCH], device 1: ALC889 &gt; Digital [ALC889 Digital]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
</code></pre>

<p>然后测试哪个能输出声音，我的显卡是card 0,device 7能真正的输出声音。</p>

<pre><code>$aplay -D plughw:0,7 /usr/share/sounds/alsa/Noise.wav 
Playing WAVE '/usr/share/sounds/alsa/Noise.wav' : Signed 16 bit Little Endian, Rate 48000 Hz, Mono
</code></pre>

<p>到这儿说明硬件都没有问题，但为什么默认不能使用呢？后来搜索到问题的原因：PulseAudio默认只会创建一个HDMI的输出设备,具体到我的电脑对应于card 0,device 3,所以无法听到声音。最终的解决办法是编辑<code>/etc/pulse/default.pa</code>文件，找到相应的加载模块的地方，添加一行：</p>

<pre><code>load-module module-alsa-sink device=hw:0,7
</code></pre>

<p>OK,大喇叭开始广播啦</p>
]]></content>
  </entry>
  
</feed>
